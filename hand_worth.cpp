// Library implementation of hand_worth.cpp#include "hand_worth.h"// hand_worth takes a hand and a table and gives it a set value// according to what is in the hand and in the community cards.// This function can be run at any time during any round. hand_worth// is primarily the function that is used when finding the player// with the best hand after betting is closed. However, the AI// in the program uses this function to give a gest or potential// that their hand has.hand hand_worth(hand &myhand, table &mytable){	int value_count[13], i, suit_count[4], value_max, suit_max, j;	card kicker_1, kicker_2;	suit_max = 0;	value_max = 0;	j = 0;	kicker_1 = myhand.big;	kicker_2 = myhand.small;		// Two arrays are created. One array, value_count, will be	// used for the card values having a length of 13. The other	// is suit_count, an array used for storing the number of	// suits of a certain type.		for (i = 0; i < 13; i++)	{		value_count[i] = 0;	}	for (i = 0; i < 4; i++)	{		suit_count[i] = 0;	}		// The following switches look at the player's hand and the	// community cards and sums them up. In otherwords, it finds	// how many clubs, spades, aces, tens, etc. that a player	// has including the table cards.		switch (myhand.big.value)	{		case 12 : value_count[12]++;				  break;		case 11 : value_count[11]++;				  break;		case 10 : value_count[10]++;				  break;		case 9 : value_count[9]++;				 break;		case 8 : value_count[8]++;				 break;		case 7 : value_count[7]++;				 break;		case 6 : value_count[6]++;				 break;		case 5 : value_count[5]++;				 break;		case 4 : value_count[4]++;				 break;		case 3 : value_count[3]++;				 break;		case 2 : value_count[2]++;				 break;		case 1 : value_count[1]++;				 break;		case 0 : value_count[0]++;				 break;	}	switch (myhand.big.suit)	{		case 3 : suit_count[3]++;				 break;		case 2 : suit_count[2]++;				 break;		case 1 : suit_count[1]++;				 break;		case 0 : suit_count[0]++;				 break;	}	switch (myhand.small.value)	{		case 12 : value_count[12]++;				  break;		case 11 : value_count[11]++;				  break;		case 10 : value_count[10]++;				  break;		case 9 : value_count[9]++;				 break;		case 8 : value_count[8]++;				 break;		case 7 : value_count[7]++;				 break;		case 6 : value_count[6]++;				 break;		case 5 : value_count[5]++;				 break;		case 4 : value_count[4]++;				 break;		case 3 : value_count[3]++;				 break;		case 2 : value_count[2]++;				 break;		case 1 : value_count[1]++;				 break;		case 0 : value_count[0]++;				 break;	}	switch (myhand.small.suit)	{		case 3 : suit_count[3]++;				 break;		case 2 : suit_count[2]++;				 break;		case 1 : suit_count[1]++;				 break;		case 0 : suit_count[0]++;				 break;	}			if (mytable.rounds == 1)	{		for (i = 0; i < 3; i++)		{				switch (mytable.community[i].value)			{				case 12 : value_count[12]++;						  break;				case 11 : value_count[11]++;						  break;				case 10 : value_count[10]++;						  break;				case 9 : value_count[9]++;						 break;				case 8 : value_count[8]++;						 break;				case 7 : value_count[7]++;						 break;				case 6 : value_count[6]++;						 break;				case 5 : value_count[5]++;						 break;				case 4 : value_count[4]++;						 break;				case 3 : value_count[3]++;						 break;				case 2 : value_count[2]++;						 break;				case 1 : value_count[1]++;						 break;				case 0 : value_count[0]++;						 break;			}			switch (mytable.community[i].suit)			{				case 3 : suit_count[3]++;						 break;				case 2 : suit_count[2]++;						 break;				case 1 : suit_count[1]++;						 break;				case 0 : suit_count[0]++;						 break;			}		}	}		if (mytable.rounds == 2)	{		for (i = 0; i < 4; i++)		{				switch (mytable.community[i].value)			{				case 12 : value_count[12]++;						  break;				case 11 : value_count[11]++;						  break;				case 10 : value_count[10]++;						  break;				case 9 : value_count[9]++;						 break;				case 8 : value_count[8]++;						 break;				case 7 : value_count[7]++;						 break;				case 6 : value_count[6]++;						 break;				case 5 : value_count[5]++;						 break;				case 4 : value_count[4]++;						 break;				case 3 : value_count[3]++;						 break;				case 2 : value_count[2]++;						 break;				case 1 : value_count[1]++;						 break;				case 0 : value_count[0]++;						 break;			}			switch (mytable.community[i].suit)			{				case 3 : suit_count[3]++;						 break;				case 2 : suit_count[2]++;						 break;				case 1 : suit_count[1]++;						 break;				case 0 : suit_count[0]++;						 break;			}		}	}	if ((mytable.rounds == 3) ||		(mytable.rounds == 4))	{		for (i = 0; i < 5; i++)		{				switch (mytable.community[i].value)			{				case 12 : value_count[12]++;						  break;				case 11 : value_count[11]++;						  break;				case 10 : value_count[10]++;						  break;				case 9 : value_count[9]++;						 break;				case 8 : value_count[8]++;						 break;				case 7 : value_count[7]++;						 break;				case 6 : value_count[6]++;						 break;				case 5 : value_count[5]++;						 break;				case 4 : value_count[4]++;						 break;				case 3 : value_count[3]++;						 break;				case 2 : value_count[2]++;						 break;				case 1 : value_count[1]++;						 break;				case 0 : value_count[0]++;						 break;			}			switch (mytable.community[i].suit)			{				case 3 : suit_count[3]++;						 break;				case 2 : suit_count[2]++;						 break;				case 1 : suit_count[1]++;						 break;				case 0 : suit_count[0]++;						 break;			}		}	}		// These loops are used to get find which value or suit	// has the most number of those cards identical. If two	// values have the same number, the higher value is stored	// as the max.		for (i = 0; i < 13; i++)	{		if ((value_count[i] > value_count[value_max]) ||			((i > value_max) && (value_count[i] == value_count[value_max])))		{			value_max = i;		}	}		for (i = 0; i < 4; i++)	{		if (suit_count[i] > suit_count[suit_max])		{			suit_max = i;		}	}		// The code to give value or worth for a hand that has a straight, 	// straight flush, or royal flush.		for (i = 8; i >= 0; i--)	{		if ((value_count[i] 			* value_count[(i + 1)]			* value_count[(i + 2)]			* value_count[(i + 3)]			* value_count[(i + 4)]) > 0)		{			if (suit_count[suit_max] >= 5)			{								// Royal flush								if (i == 8)				{										// Along with assigning a set type (i.e. pair, flush, etc.),					// which is translated to an integer value between 0 to 9,					// 9 being a royal flush, a decimal or remainder is added to					// that integer. This comes from the kind of kickers, high					// pair, beginning straight card, etc. that the hand might					// also contain.										myhand.type = 9;					if (suit_count[kicker_1.suit] == 5)					{						if (suit_count[kicker_2.suit] == 5)						{							return myhand;						}						else						{							myhand.type = 								(myhand.type + ((float (kicker_2.value)) / (13 * 13)));							return myhand;						}					}					else					{						myhand.type = 							(myhand.type + ((float (kicker_1.value)) / (13 * 13)));						return myhand;					}				}								// Straight flush								else				{					myhand.type = (8 + ((float (i + 4)) / 13));					if (suit_count[kicker_1.suit] == 5)					{						if (suit_count[kicker_2.suit] == 5)						{							return myhand;						}						else						{							myhand.type = 								(myhand.type + ((float (kicker_2.value)) / (13 * 13)));							return myhand;						}					}					else					{						myhand.type = 							(myhand.type + ((float (kicker_1.value)) / (13 * 13)));						return myhand;					}				}			}						// Straight						else			{				myhand.type = (4 + ((float (i + 4)) / 13));				if (((kicker_1.value == i) && (value_count[i] == 1)) ||					((kicker_1.value == (i + 1)) && (value_count[(i + 1)] == 1)) ||					((kicker_1.value == (i + 2)) && (value_count[(i + 2)] == 1)) ||					((kicker_1.value == (i + 3)) && (value_count[(i + 3)] == 1)) ||					((kicker_1.value == (i + 4)) && (value_count[(i + 4)] == 1)))				{					if (((kicker_1.value == i) && (value_count[i] == 1)) ||						((kicker_1.value == (i + 1)) && (value_count[(i + 1)] == 1)) ||						((kicker_1.value == (i + 2)) && (value_count[(i + 2)] == 1)) ||						((kicker_1.value == (i + 3)) && (value_count[(i + 3)] == 1)) ||						((kicker_1.value == (i + 4)) && (value_count[(i + 4)] == 1)))					{						return myhand;					}					else					{						myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));						return myhand;					}				}				else				{					myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));					return myhand;				}			}		}	}		// Code for the special case a player might get a straight of	// ace, two, three, four, and five.		if ((value_count[12]		* value_count[0]		* value_count[1]		* value_count[2]		* value_count[3]) > 0)	{		myhand.type = (4 + (3 / 13));		if (((kicker_1.value == 12) && (value_count[12] == 1)) ||			((kicker_1.value == 1) && (value_count[1] == 1)) ||			((kicker_1.value == 2) && (value_count[2] == 1)) ||			((kicker_1.value == 3) && (value_count[3] == 1)) ||			((kicker_1.value == 0) && (value_count[0] == 1)))		{			if (((kicker_1.value == 12) && (value_count[12] == 1)) ||				((kicker_1.value == 1) && (value_count[1] == 1)) ||				((kicker_1.value == 2) && (value_count[2] == 1)) ||				((kicker_1.value == 3) && (value_count[3] == 1)) ||				((kicker_1.value == 0) && (value_count[0] == 1)))			{				return myhand;			}			else			{				myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));				return myhand;			}		}		else		{			myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));			return myhand;		}				return myhand;	}		// Flush		if (suit_count[suit_max] == 5)	{		myhand.type = 5;		j = 0;		if ((myhand.big.suit == suit_max) &&			(myhand.big.value > j))		{			j = myhand.big.value;		}		if ((myhand.small.suit == suit_max) &&			(myhand.small.value > j))		{			j = myhand.small.value;		}		if (mytable.rounds == 1)		{			for (i = 0; i < 3; i++)			{				if ((mytable.community[i].suit == suit_max) &&					(mytable.community[i].value > j))				{					j = mytable.community[i].value;				}			}		}		if (mytable.rounds == 2)		{			for (i = 0; i < 4; i++)			{				if ((mytable.community[i].suit == suit_max) &&					(mytable.community[i].value > j))				{					j = mytable.community[i].value;				}			}		}		if (mytable.rounds == 3)		{			for (i = 0; i < 5; i++)			{				if ((mytable.community[i].suit == suit_max) &&					(mytable.community[i].value > j))				{					j = mytable.community[i].value;				}			}		}		myhand.type = (myhand.type + ((float (j)) / 13));		if (suit_count[kicker_1.suit] == 5)		{			if (suit_count[kicker_2.suit] == 5)			{				return myhand;			}			else			{				myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));				return myhand;			}		}		else		{			myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));			return myhand;		}		return myhand;	}			// Four of a kind		if (value_count[value_max] == 4)	{		myhand.type = (7 + ((float (value_max)) / 13));		if (kicker_1.value == value_max)		{			if (kicker_2.value == value_max)			{				return myhand;			}			else			{				myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));				return myhand;			}		}		else		{			myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));			return myhand;		}	}		// Three of a kind		if (value_count[value_max] == 3)	{		for (i = 0; i < 13; i++)		{			if ((value_count[i] >= 2) &&				(i != value_max))			{				myhand.type = (6 + ((float (value_max)) / 13));				if (((kicker_1.value == i) && (value_count[i] == 2)) ||					(kicker_1.value == value_max))				{					if (((kicker_2.value == i) && (value_count[i] == 2)) ||						(kicker_2.value == value_max))					{						return myhand;					}											else					{						myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));						return myhand;					}				}				else				{					myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));					return myhand;				}			}		}		myhand.type = (3 + ((float (value_max)) / 13));		if (kicker_1.value == value_max)		{			if (kicker_2.value == value_max)			{				return myhand;			}			else			{				myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));				return myhand;			}		}		else		{			myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));			return myhand;		}		return myhand;	}		if (value_count[value_max] == 2)	{		for (i = 0; i < 13; i++)		{						// Two pair						if ((i != value_max) &&				(value_count[i] == 2))			{				myhand.type = (2 + ((float (value_max)) / 13));				if ((kicker_1.value == i) ||					(kicker_1.value == value_max))				{					if ((kicker_2.value == i) ||						(kicker_2.value == value_max))					{						return myhand;					}					else					{						myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));						return myhand;					}				}				else				{					myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));					return myhand;				}							}		}				// Pair				myhand.type = (1 + ((float (value_max)) / 13));		if (kicker_1.value == value_max)		{			myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));			return myhand;		}		else		{			myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));			return myhand;		}		return myhand;	}		// High card		if (value_count[value_max] == 1)	{		myhand.type = ((float (value_max)) / 13);		if (kicker_1.value == value_max)		{			myhand.type = (myhand.type + ((float (kicker_2.value)) / (13 * 13)));			return myhand;		}		else		{			myhand.type = (myhand.type + ((float (kicker_1.value)) / (13 * 13)));			return myhand;		}		return myhand;	}	return myhand;}